% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bernstein.R
\name{distributions_bernstein_densities}
\alias{distributions_bernstein_densities}
\alias{dxbernstein}
\alias{dbernstein}
\alias{pbernstein}
\title{Density, distribution function, quantile function, random generation, and
pth derivative for a Bernstein density with parameter vector \code{lambda}.}
\usage{
dxbernstein(x, lambda, p = 1, support = c(0, 1), log = FALSE)

dbernstein(x, lambda, p = 1, support = c(0, 1), log = FALSE)

pbernstein(x, lambda, p = 1, support = c(0, 1), log.p = FALSE)
}
\arguments{
\item{x, q}{vector of quantiles.}

\item{lambda}{A vector of positive weights summing to 1.}

\item{p}{vector of probabilities.}

\item{support}{The support of the}

\item{log, log.p}{logical; if \code{TRUE}, probabilities p are given as log(p).}

\item{n}{number of observations. If code{length(n) > 1}, the length is taken
to be the number required.}

\item{lower.tail}{logical; if  \code{TRUE} (default), probabilities are \eqn{P[x\leX]} otherwise, \eqn{P[X<x]}.}
}
\value{
\code{dbernstein} gives the density, \code{pbernstein} the distribution function, \code{qbernstein}
the quantile function, \code{rbeta} generates random deviates, and \code{dxbernstein} gives the pth
derivative of the density function.
}
\description{
Density, distribution function, quantile function, random generation, and
pth derivative for a Bernstein density with parameter vector \code{lambda}.
}
\section{Functions}{
\itemize{
\item \code{dxbernstein}: Calculates pth derivative of a
Bernstein density.

\item \code{dbernstein}: Calculates a Bernstein
density.

\item \code{pbernstein}: Calculates the distribution
function of a Bernstein density.
}}

\examples{
## Do a parametric bootstrap.
set.seed(1337)
data = rbeta(200, 2, 7)
polygram_object = polygram(data, s = 3, m = 4)
current_median = qpolygram(0.5, polygram_object)
medians = replicate(100, {
  new_data = rpolygram(200, polygram_object)
  new_median = qpolygram(0.5, polygram(new_data, s = 3, m = 4))
  new_median
})
plot(polygram(sqrt(200)*(current_median - medians), s = 4, m = 4,
              support = c(-1,1)))
}
